package main

import (
	"fmt"
	"io/ioutil"
	"strings"
)

func main() {
	bytes, _ := ioutil.ReadFile("data.txt")
	puzzleInput := string(bytes)
	fmt.Println(Answer1(puzzleInput))
	fmt.Println(Answer2(puzzleInput))
}

type cave struct {
	key     string
	size    string
	visited bool
	targets []*cave
}

type node struct {
	cave    *cave
	toVisit []*node
	visited []*node
}

func (t cave) String() string {
	targetKeys := []string{}
	for _, target := range t.targets {
		targetKeys = append(targetKeys, target.key)
	}
	return fmt.Sprintf("{%v %v %v %v}", t.key, t.size, t.visited, targetKeys)
}

func (t node) String() string {
	return fmt.Sprintf("{%v %v %v}", t.cave.key, t.toVisit, t.visited)
}

func Answer1(puzzleInput string) int {
	lines := strings.Split(puzzleInput, "\n")
	caves := convertLinesToCaves(lines)
	printCaves(caves)

	tree := []*node{}
	currentCave := caves["start"]
	currentNode := &node{currentCave, []*node{}, []*node{}}
	tree = append(tree, currentNode)
	printTree(tree)

	path := []string{}
	paths := [][]string{}

	path = append(path, currentNode.cave.key)
	fmt.Println("Path:", path)
	fmt.Println("Paths:", paths)

	for {
		targets := filterTargets(currentCave.targets, path, paths)
		fmt.Println("Targets:", targets)

		if len(targets) == 0 {
			fmt.Println("No allowed target found")
			break
		}

		target := targets[0]
		path = append(path, target.key)

		if target.key == "end" {
			fmt.Println("End of path reached")
			paths = append(paths, path)
			path = []string{}
			break
		}

		fmt.Println("Target", target)
		break
	}

	fmt.Println("Path:", path)
	fmt.Println("Paths:", paths)

	return 10
}

// Return only the targets that are allowed to go to
func filterTargets(targets []*cave, path []string, paths [][]string) []*cave {
	filtered := []*cave{}
	for _, target := range targets {
		// It's not allowed if target is small and visited
		if target.size == "small" && target.visited == true {
			continue
		}

		// It's not allowed if target is the end and the path already exists
		newPath := append(path, target.key)
		if target.key == "A" && doesPathExist(newPath, paths) {
			continue
		}

		filtered = append(filtered, target)
	}
	return filtered
}

// Check if the path exists to prevent duplicate paths
func doesPathExist(path []string, paths [][]string) bool {
	exists := false
	for _, existingPath := range paths {
		pathString := strings.Join(path, ",")
		existingPathString := strings.Join(existingPath, ",")
		if pathString == existingPathString {
			exists = true
		}
	}
	return exists
}

func printTree(tree []*node) {
	fmt.Println("Tree:")
	for key, node := range tree {
		fmt.Println(key, node)
	}
}

func printCaves(caves map[string]*cave) {
	fmt.Println("Caves:")
	for _, cave := range caves {
		fmt.Println(cave)
	}
}

func convertLinesToCaves(lines []string) map[string]*cave {
	caves := map[string]*cave{}

	// Create caves
	for _, line := range lines {
		caveKeys := strings.Split(line, "-")
		for _, caveKey := range caveKeys {
			size := "small"
			if strings.ToUpper(caveKey) == caveKey {
				size = "big"
			}
			if caveKey == "start" || caveKey == "end" {
				size = "nil"
			}

			caves[caveKey] = &cave{caveKey, size, false, []*cave{}}
		}
	}

	// Find destinations which you can reach from the specific cave
	for _, line := range lines {
		caveKeys := strings.Split(line, "-")
		from := caveKeys[0]
		to := caveKeys[1]
		caveFrom := caves[from]
		caveTo := caves[to]

		// Add the 'to' location to the 'from' cave destinations
		caveFrom.targets = append(caveFrom.targets, caves[to])

		// Reverse the route: also add the 'from' location to the 'to' cave destinations
		// Restrictions: you can't reverse from the end and you can't go back to the start
		if to != "end" && from != "start" {
			caveTo.targets = append(caveTo.targets, caveFrom)
		}
	}
	return caves
}

func Answer2(puzzleInput string) int {
	// lines := strings.Split(puzzleInput, "\n")
	return 0
}
